# 耍杂技的牛

* 农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。 奶牛们不是非常有创意，只提出了一个杂技表演：叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

**思路**

* 将所有牛的wi + si 从小到大排序，结果一定是最优的。

* 证明：
    - 贪心得到的答案 >= 最优解 （无须证明，因为贪心得到的答案必定是一种解决方案，所以一定>=最优解）
    
    - 贪心得到的方案 <= 最优解

    - 假设最优解不是按照贪心算法来选的，则必定存在一个 wi + si > w(i+1) + s(i+1)
    
    - 交换前第i个位置上的风险值为 w1 + w2 + ... + wi-1 - si

    - 交换前第i+1个位置上的风险值为 w1 + w2 + ... + wi - si+1

    - 交换后第i个位置上的风险值为 w1 + w2 + ... + wi-1 - si+1

    - 交换后第i+1个位置上的风险值为 w1 + w2 + ... + wi+1 - si

    - 都有 w1 + ... wi-1 + si-1 项删掉，剩余的再加一个(si + si+1)

    - 交换前第i个位置上的风险值为 si+1

    - 交换前第i+1个位置上的风险值为 wi + si

    - 交换后第i个位置上的风险值为 si

    - 交换后第i+1个位置上的风险值为 wi+1 + si+1

    - 发现交换后第i+1个位置上的风险值变小了，要求风险值最大值最下，所以 wi+si > max(si, wi+1 + si+1), 即交换后第i和第i+1位置上的最大值小于交换前的最大值，故交换是合适的。
 
    

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 50010;
int n;
PII cow[N];

int main()
{

    scanf("%d", &n);

    for (int i = 0; i < n; i++)
    {
        int w, s;
        scanf("%d%d", &w, &s);
        cow[i] = {w + s, w}; 
    }

    sort(cow, cow + n);
    int res = -2e9, sum = 0;
    for (int i = 0; i < n; i++)
    {
        int w = cow[i].second, s = cow[i].first - w;
        res = max(res, sum - s);
        sum += w;
    }

    printf("%d", res);

    return 0;
}


```




